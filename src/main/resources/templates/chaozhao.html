<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>查找</title>
		<meta http-equiv="Content-Style-Type" content="text/css" />
		<link href="static/css/title.css" rel="stylesheet"  />
		<script type="text/javascript" src="static/js/jquery.js"></script>
		<script type="text/javascript" src="static/js/jquery.idTabs.min.js"></script>
		<script type="text/javascript" src="static/js/select-ui.min.js"></script>
		<script type="text/javascript" src="static/editor/kindeditor.js"></script>
		<meta name="generator" content="Aspose.Words for .NET 15.1.0.0" />



	</head>
	<body>
	<div class="place">
		<span>位置：</span>
		<ul class="placeul">
			<li><a href="leftHtml">数据结构知识点管理系统</a></li>
			<li>数据结构</li>
		</ul>
	</div>
		<div>
			<p style="border-bottom-color:#4472c4; border-bottom-style:solid; border-bottom-width:0.75pt; border-top-color:#4472c4; border-top-style:solid; border-top-width:0.75pt; margin:18pt 43.2pt; orphans:0; padding-bottom:10pt; padding-top:10pt; text-align:center; widows:0">
				<span style="color:#4472c4; font-family:华光彩云_CNKI; font-size:36pt; font-style:normal; font-weight:bold">
					查找
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:center; widows:0">
				<a name="sub58783_1_1">
				</a>
				<a name="常见排序算法">
					<span style="-aw-bookmark-end:sub58783_1_1">
					</span>
				</a>
				<span style="color:#4472c4; font-family:华文彩云; font-size:22pt; font-weight:bold">
					基础概念
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					1）查找表：同一类型的数据元素的集合。
				</span>
				<br />
				<span style="width:21pt; text-indent:0pt; display:inline-block">
				</span>
				<span style="font-family:等线; font-size:12pt">
					2）关键字Key：关键字是数据元素或记录中某个数据项的值，用它可以标识一个数据元素或记录。若此关键字可以唯一地标识一个记录，则成此关键字为主关键字，反之，称用以识别若干记录的关键字为次关键字。
				</span>
				<br />
				<span style="width:21pt; text-indent:0pt; display:inline-block">
				</span>
				<span style="font-family:等线; font-size:12pt">
					3）查找：查找是指根据给定的某个值，在查找表中确定一个其关键字等于给定值得记录或数据元素。若表中存在这样一个记录，则称查找成功，否则，查找失败。
				</span>
				<br />
				<span style="width:21pt; text-indent:0pt; display:inline-block">
				</span>
				<span style="font-family:等线; font-size:12pt">
					4）动态查找：若在查找过程中对表做修改操作（如插入和删除），则相应的表称之为动态查找。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					5）静态查找：只对查找表进行查询某个特定的数据元素或某个特定数据元素的各种属性的操作。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					6）平均查找长度ASL：
				</span>
				<span style="font-family:等线; font-size:12pt">
					为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值称为查找算法在查找成功时的平均查找长度
				</span>
				<span style="font-family:等线; font-size:12pt">
					，
				</span>
				<span style="font-family:等线; font-size:12pt">
					成功。对于含有n
				</span>
				<span style="font-family:等线; font-size:12pt">
					个
				</span>
				<span style="font-family:等线; font-size:12pt">
					数据元素的查找表，查找成功的平均查找长度为：ASL=∑
				</span>
				<span style="font-family:等线; font-size:12pt">
					PiCi
				</span>
				<span style="font-family:等线; font-size:12pt">
					(
				</span>
				<span style="font-family:等线; font-size:12pt">
					i
				</span>
				<span style="font-family:等线; font-size:12pt">
					=1,
				</span>
				<span style="font-family:等线; font-size:12pt">
					2,3,…
				</span>
				<span style="font-family:等线; font-size:12pt">
					,n),可以简单以数学上的期望来这么理解。其中：Pi 为查找表中第
				</span>
				<span style="font-family:等线; font-size:12pt">
					i
				</span>
				<span style="font-family:等线; font-size:12pt">
					个数据元素的概率，Ci为找到第
				</span>
				<span style="font-family:等线; font-size:12pt">
					i
				</span>
				<span style="font-family:等线; font-size:12pt">
					个数据元素时已经比较过的次数。在查找表中查找不到待查元素，但是找到待查元素应该在表中存在的位置的平均查找次数称为查找不成功时的平均查找长度，不成功。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					7）空间复杂度(Space Complexity)：空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"
				target="https://baike.baidu.com/item/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/_blank">
					<span style="font-family:等线; font-size:12pt">
						插入排序
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					的
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/1894057"
				target="https://baike.baidu.com/item/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/_blank">
					<span style="font-family:等线; font-size:12pt">
						时间复杂度
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					是O(n^2),空间复杂度是O(1) 。而一般的
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92"
				target="https://baike.baidu.com/item/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/_blank">
					<span style="font-family:等线; font-size:12pt">
						递归
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					8）查找算法的衡量标准：
				</span>
				<span style="font-family:等线; font-size:12pt">
					一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E8%A1%A1%E9%87%8F/483075"
				target="https://baike.baidu.com/item/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/_blank">
					<span style="font-family:等线; font-size:12pt">
						衡量
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					。对于一个算法，其
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"
				target="https://baike.baidu.com/item/%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/_blank">
					<span style="font-family:等线; font-size:12pt">
						时间复杂度
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					和空间复杂度往往是相互影响的。
				</span>
				<span style="font-family:等线; font-size:12pt">
					当追求
				</span>
				<span style="font-family:等线; font-size:12pt">
					一个较好的时间复
				</span>
				<span style="font-family:等线; font-size:12pt">
					杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，
				</span>
				<span style="font-family:等线; font-size:12pt">
					当追求
				</span>
				<span style="font-family:等线; font-size:12pt">
					一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。另外，算法的所有性能之间都存在着或多或少的相互影响。因此，当设计一个算法(特别是大型算法)时，要综合考虑算法的各项性能，算法的使用频率，算法处理的数据量的大小，算法描述语言的特性，算法运行的机器系统环境等各方面因素，才能够设计出比较好的算法。算法的时间复杂度和空间复杂度合称为算法的复杂
				</span>
				<span style="font-family:等线; font-size:12pt">
					度。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:center; widows:0">
				<span style="color:#4472c4; font-family:华文彩云; font-size:22pt; font-weight:bold">
					顺序查找
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt; font-weight:normal">
					从表的一端开始，依次将记录的关键字和给定值进行比较，若某个记录的关键字和给定值相等，则查找成功，反之
				</span>
				<span style="font-family:等线; font-size:12pt; font-weight:normal">
					。查找失败。
				</span>
				<br />
				<span style="width:21pt; text-indent:0pt; display:inline-block">
				</span>
				<span style="font-family:等线; font-size:12pt; font-weight:normal">
					顺序查找方法即适用于线性表的顺序存储结构，也适用于线性表的链式存储结构。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
					代码实现
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					int
				</span>
				<span style="font-family:等线; font-size:12pt">
					aq_
				</span>
				<span style="font-family:等线; font-size:12pt">
					search
				</span>
				<span style="font-family:等线; font-size:12pt">
					(
				</span>
				<span style="font-family:等线; font-size:12pt">
					keytype
				</span>
				<span style="font-family:等线; font-size:12pt">
				</span>
				<span style="font-family:等线; font-size:12pt">
					keyp
				</span>
				<span style="font-family:等线; font-size:12pt">
					[],int
				</span>
				<span style="font-family:等线; font-size:12pt">
					n,keytype
				</span>
				<span style="font-family:等线; font-size:12pt">
					key){
				</span>
			</p>
			<p style="margin:0pt 0pt 0pt 21pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					int
				</span>
				<span style="font-family:等线; font-size:12pt">
					i
				</span>
				<span style="font-family:等线; font-size:12pt">
					;
				</span>
			</p>
			<p style="margin:0pt 0pt 0pt 21pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					f
				</span>
				<span style="font-family:等线; font-size:12pt">
					or(
				</span>
				<span style="font-family:等线; font-size:12pt">
					i
				</span>
				<span style="font-family:等线; font-size:12pt">
					=
				</span>
				<span style="font-family:等线; font-size:12pt">
					0;i
				</span>
				<span style="font-family:等线; font-size:12pt">
					&lt;
				</span>
				<span style="font-family:等线; font-size:12pt">
					n;i
				</span>
				<span style="font-family:等线; font-size:12pt">
					++)
				</span>
			</p>
			<p style="margin:0pt 0pt 0pt 21pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					if(key[
				</span>
				<span style="font-family:等线; font-size:12pt">
					i
				</span>
				<span style="font-family:等线; font-size:12pt">
					] == key)
				</span>
			</p>
			<p style="margin:0pt 0pt 0pt 21pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					r
				</span>
				<span style="font-family:等线; font-size:12pt">
					eturn I;
				</span>
			</p>
			<p style="margin:0pt 0pt 0pt 21pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					r
				</span>
				<span style="font-family:等线; font-size:12pt">
					eturn -1;
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					}
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
					设置监视哨的顺序查找
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					监视哨往往是程序里面的一个
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E5%8F%98%E9%87%8F"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						变量
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					，如果是对数字排序的话，那么该变量一般是数值型变量。
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E5%8F%98%E9%87%8F"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						变量
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					的赋值就相当于哨兵，当排序数列中出现与哨兵相等的值或有某种既定关系出现时，就做一种操作，比如说停止排序，或进行下一趟排序。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="color:#4472c4; font-family:等线; font-size:14pt; font-variant:small-caps; font-weight:bold; letter-spacing:0.25pt">
					代码实现
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					Int
				</span>
				<span style="font-family:等线; font-size:12pt">
					Search_
				</span>
				<span style="font-family:等线; font-size:12pt">
					Seq
				</span>
				<span style="font-family:等线; font-size:12pt">
					(
				</span>
				<span style="font-family:等线; font-size:12pt">
					SSTable
				</span>
				<span style="font-family:等线; font-size:12pt">
				</span>
				<span style="font-family:等线; font-size:12pt">
					ST,keyType
				</span>
				<span style="font-family:等线; font-size:12pt">
					key){
				</span>
			</p>
			<p style="margin:0pt 0pt 0pt 21pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					S
				</span>
				<span style="font-family:等线; font-size:12pt">
					T.R[0].
				</span>
				<span style="font-family:等线; font-size:12pt">
					key
				</span>
				<span style="font-family:等线; font-size:12pt">
				</span>
				<span style="font-family:等线; font-size:12pt">
					=
				</span>
				<span style="font-family:等线; font-size:12pt">
				</span>
				<span style="font-family:等线; font-size:12pt">
					key；
				</span>
			</p>
			<p style="margin:0pt 0pt 0pt 21pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					f
				</span>
				<span style="font-family:等线; font-size:12pt">
					o
				</span>
				<span style="font-family:等线; font-size:12pt">
					r(
				</span>
				<span style="font-family:等线; font-size:12pt">
					I =
				</span>
				<span style="font-family:等线; font-size:12pt">
					ST.length;ST.R
				</span>
				<span style="font-family:等线; font-size:12pt">
					[
				</span>
				<span style="font-family:等线; font-size:12pt">
					i
				</span>
				<span style="font-family:等线; font-size:12pt">
					].key !=
				</span>
				<span style="font-family:等线; font-size:12pt">
					key;i
				</span>
				<span style="font-family:等线; font-size:12pt">
					--);
				</span>
			</p>
			<p style="margin:0pt 0pt 0pt 21pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					return I;
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					}
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="_Hlk48142551">
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						时间复杂度分析
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="-aw-bookmark-end:_Hlk48142551">
				</span>
				<span style="font-family:等线; font-size:12pt">
					查找成功时 ASL=（1+2+3+……+n）/n=(n+1)/2
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					查找成功时 ASL=（1+n）*n/n=n+1
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
					特点
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					1）算法简单，对查找表的结点之间没有排序要求，对表的存储结构也无任何要求。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					2）n很大时查找效率较低，与n成反比，平均约为n/2
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					3）改进措施：非等概率查找时，可按照查找概率进行排序。若从前向后顺序查找，则更适合按照概率从大到小排序；若从后向前顺序查找，则更适合按照概率从小到大排序。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:center; widows:0">
				<span style="color:#4472c4; font-family:华文彩云; font-size:22pt; font-weight:bold">
					折半查找
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="_Toc30977">
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						查找过程
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					首先，假设表中元素是按升序排列，将表中间位置记录的
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						关键字
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E8%AE%B0%E5%BD%95/1837758"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						记录
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E8%AE%B0%E5%BD%95/1837758"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						记录
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					，使查找成功，或
				</span>
				<span style="font-family:等线; font-size:12pt">
					直到子表不
				</span>
				<span style="font-family:等线; font-size:12pt">
					存在为止，此时查找不成功。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="_">
				</a>
				<a name="sub610605_2">
				</a>
				<a name="算法要求">
				</a>
				<a name="_Toc32178">
					<span style="-aw-bookmark-end:_">
					</span>
					<span style="-aw-bookmark-end:sub610605_2">
					</span>
					<span style="-aw-bookmark-end:算法要求">
					</span>
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						代码实现
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<img src="static/images/chazhao1.png" width="683" height="432"
				alt="" style="-aw-left-pos:0pt; -aw-rel-hpos:column; -aw-rel-vpos:paragraph; -aw-top-pos:0pt; -aw-wrap-type:inline"
				/>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
					比较次数
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					计算公式：
				</span>
				<span style="font-family:等线; font-size:12pt">
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					当顺序表有n
				</span>
				<span style="font-family:等线; font-size:12pt">
					个
				</span>
				<span style="font-family:等线; font-size:12pt">
					关键字时：
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					查找失败时，至少比较a次关键字；查找成功时，最多比较关键字次数是b。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					注意：
				</span>
				<span style="font-family:等线; font-size:12pt">
					a,b,n
				</span>
				<span style="font-family:等线; font-size:12pt">
					均为正整数。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="_Toc7160">
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						算法复杂度
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					二分查找的基本思想是将n
				</span>
				<span style="font-family:等线; font-size:12pt">
					个
				</span>
				<span style="font-family:等线; font-size:12pt">
					元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x&lt;a[n/2],则只要在数组a的左半部分继续搜索x,如果x&gt;a[n/2],则只要在数组a的右半部搜索x.
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					时间复杂度即是while循环的次数。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					总共有n
				</span>
				<span style="font-family:等线; font-size:12pt">
					个
				</span>
				<span style="font-family:等线; font-size:12pt">
					元素，
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					渐渐跟
				</span>
				<span style="font-family:等线; font-size:12pt">
					下去就是
				</span>
				<span style="font-family:等线; font-size:12pt">
					n,n
				</span>
				<span style="font-family:等线; font-size:12pt">
					/2,n/4,....n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					由于n/2^k取整后&gt;=1
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					即令n/2^k=1
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					可得k=log2n,（是以2为底，n的对数）
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					所以时间复杂度可以表示O(h)=O(log2n)
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:center; widows:0">
				<span style="color:#4472c4; font-family:华文彩云; font-size:22pt; font-weight:bold">
					二叉排序
				</span>
				<span style="color:#4472c4; font-family:华文彩云; font-size:22pt; font-weight:bold">
					树
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					二叉排序
				</span>
				<span style="font-family:等线; font-size:12pt">
					树（Binary Sort Tree），又称
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/7077965"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						二叉查找
					</span>
					<span style="font-family:等线; font-size:12pt">
						树
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					（Binary Search Tree），亦称
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/7077855"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						二叉搜索树
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="_Toc18104">
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						定义
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					一棵空树，或者是具有下列性质的
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						二叉树
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					：
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					2）
				</span>
				<span style="font-family:等线; font-size:12pt">
					若右子
				</span>
				<span style="font-family:等线; font-size:12pt">
					树不空，
				</span>
				<span style="font-family:等线; font-size:12pt">
					则右子树上
				</span>
				<span style="font-family:等线; font-size:12pt">
					所有结点的值均大于它的根结点的值；
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					3）左、
				</span>
				<span style="font-family:等线; font-size:12pt">
					右子树
				</span>
				<span style="font-family:等线; font-size:12pt">
					也分别
				</span>
				<span style="font-family:等线; font-size:12pt">
					为二叉排序
				</span>
				<span style="font-family:等线; font-size:12pt">
					树；
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					4）没有键值相等的结点。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="_Toc25203">
					<span style="color:#4472c4; font-family:等线; font-size:14pt; font-variant:small-caps; font-weight:normal; letter-spacing:0.25pt">
						查找
					</span>
					<span style="color:#4472c4; font-family:等线; font-size:14pt; font-variant:small-caps; font-weight:normal; letter-spacing:0.25pt">
						步骤
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					若根结点
				</span>
				<span style="font-family:等线; font-size:12pt">
					的
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						关键字
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					值等于查找的关键字，
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%88%90%E5%8A%9F/38457"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						成功
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					。否则，若小于根结点的关键字值，
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E9%80%92%E5%BD%92"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						递归
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					查左子树。若大于根结点的关键字值，递归
				</span>
				<span style="font-family:等线; font-size:12pt">
					查右子树
				</span>
				<span style="font-family:等线; font-size:12pt">
					。若子树为空，查找不成功。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="_Toc9887">
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						插入删除
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					与次优二叉树相对，
				</span>
				<span style="font-family:等线; font-size:12pt">
					二叉排序
				</span>
				<span style="font-family:等线; font-size:12pt">
					树是一种动态树表。其特点是：树的结构通常不是一次生成的，而是在查找过程中，当树中不存在
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						关键字
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					等于给定值的
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E7%BB%93%E7%82%B9"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						结点
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					时再进行插入。新插入的结点一定是一个新添加的
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						叶子结点
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					，并且是查找不成功时查找路径上访问的最后一个结点的
				</span>
				<span style="font-family:等线; font-size:12pt">
					左孩子或右孩子
				</span>
				<span style="font-family:等线; font-size:12pt">
					结点。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="color:#4472c4; font-family:等线; font-size:14pt; font-variant:small-caps; font-weight:bold; letter-spacing:0.25pt">
					插入算法
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					首先执行查找算法，找出被插结点的父亲结点。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					判断被插结点是其父亲结点的左、右儿子。将被插结点作为
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						叶子结点
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					插入。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					若
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						二叉树
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					为空。则首先单独生成根结点。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					注意：新插入的结点总是叶子结点
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="color:#4472c4; font-family:等线; font-size:14pt; font-variant:small-caps; font-weight:bold; letter-spacing:0.25pt">
					删除结点
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					在二叉排序
				</span>
				<span style="font-family:等线; font-size:12pt">
					树删去一个结点，分三种情况讨论：
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					1）
				</span>
				<span style="font-family:等线; font-size:12pt">
					若*p结点为叶子结点，即PL(左子树)和PR(
				</span>
				<span style="font-family:等线; font-size:12pt">
					右子树
				</span>
				<span style="font-family:等线; font-size:12pt">
					)均为空树。由于删去叶子结点不破坏整棵树的结构，则可以直接删除此子结点。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					2）
				</span>
				<span style="font-family:等线; font-size:12pt">
					若*p结点只有左子树PL
				</span>
				<span style="font-family:等线; font-size:12pt">
					或右子树
				</span>
				<span style="font-family:等线; font-size:12pt">
					PR，此时只要令PL或PR直接成为其双亲结点*f的左子树（当*p是左子树）
				</span>
				<span style="font-family:等线; font-size:12pt">
					或右子树
				</span>
				<span style="font-family:等线; font-size:12pt">
					（当*p
				</span>
				<span style="font-family:等线; font-size:12pt">
					是右子树
				</span>
				<span style="font-family:等线; font-size:12pt">
					）即可，作此修改也不
				</span>
				<span style="font-family:等线; font-size:12pt">
					破坏二叉排序
				</span>
				<span style="font-family:等线; font-size:12pt">
					树的特性。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					3）
				</span>
				<span style="font-family:等线; font-size:12pt">
					若*p结点的左子树
				</span>
				<span style="font-family:等线; font-size:12pt">
					和右子树
				</span>
				<span style="font-family:等线; font-size:12pt">
					均不空。在删去*p之后，为保持其它元素之间的相对位置不变，可
				</span>
				<span style="font-family:等线; font-size:12pt">
					按中序遍历
				</span>
				<span style="font-family:等线; font-size:12pt">
					保持有序进行调整，可以有两种做法：
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					其一是令*p的左子树为*f的左/右(依*p是*f的左子树
				</span>
				<span style="font-family:等线; font-size:12pt">
					还是右子树
				</span>
				<span style="font-family:等线; font-size:12pt">
					而定)子树，*s为*p左子树的最右下的结点，而*p
				</span>
				<span style="font-family:等线; font-size:12pt">
					的右子树为
				</span>
				<span style="font-family:等线; font-size:12pt">
					*s
				</span>
				<span style="font-family:等线; font-size:12pt">
					的右子树
				</span>
				<span style="font-family:等线; font-size:12pt">
					；
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					其二是令*p的直接前驱（或直接后继）替代*p，然后再
				</span>
				<span style="font-family:等线; font-size:12pt">
					从二叉排序
				</span>
				<span style="font-family:等线; font-size:12pt">
					树中删去它的直接前驱（或直接后继）－即让*f的左子树(如果有的话)成为*p左子树的最左下结点(如果有的话)，再让*f成为*p的左右结点的父结点。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="_Toc13104">
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						性能分析
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					每个结点的C(
				</span>
				<span style="font-family:等线; font-size:12pt">
					i
				</span>
				<span style="font-family:等线; font-size:12pt">
					)为该结点的层次数。最坏情况下，当先后插入的关键字有序时，构成
				</span>
				<span style="font-family:等线; font-size:12pt">
					的二叉排序
				</span>
				<span style="font-family:等线; font-size:12pt">
					树蜕变为单支树，树的深度为其
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E5%B9%B3%E5%9D%87%E6%9F%A5%E6%89%BE%E9%95%BF%E5%BA%A6"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						平均查找长度
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					(n+1)/2(和顺序查找相同），最好的情况
				</span>
				<span style="font-family:等线; font-size:12pt">
					是二叉排序
				</span>
				<span style="font-family:等线; font-size:12pt">
					树的形态和折半查找的判定树相同，其平均查找长度和log 2 (n)成正比。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:center; widows:0">
				<a name="_Toc25771">
					<span style="color:#4472c4; font-family:华文彩云; font-size:22pt; font-weight:bold">
						平衡二叉树
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					在
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/9132"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						计算机科学
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					中，AVL树是最先发明的自
				</span>
				<span style="font-family:等线; font-size:12pt">
					平衡二叉查找
				</span>
				<span style="font-family:等线; font-size:12pt">
					树。在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。增加和删除可能需要通过一次或多次
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%A0%91%E6%97%8B%E8%BD%AC"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						树旋转
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					来重新平衡这个树。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="_Toc25440">
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						特点
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					AVL树本质上还是
				</span>
				<span style="font-family:等线; font-size:12pt">
					一棵二叉搜索树
				</span>
				<span style="font-family:等线; font-size:12pt">
					，它的特点是：
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					1.本身首先是
				</span>
				<span style="font-family:等线; font-size:12pt">
					一棵二叉搜索树
				</span>
				<span style="font-family:等线; font-size:12pt">
					。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					也就是说，AVL树，本质上是带了平衡功能
				</span>
				<span style="font-family:等线; font-size:12pt">
					的二叉查找
				</span>
				<span style="font-family:等线; font-size:12pt">
					树（
				</span>
				<span style="font-family:等线; font-size:12pt">
					二叉排序
				</span>
				<span style="font-family:等线; font-size:12pt">
					树，
				</span>
				<span style="font-family:等线; font-size:12pt">
					二叉搜索树
				</span>
				<span style="font-family:等线; font-size:12pt">
					）。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="sub671745_2">
				</a>
				<a name="操作">
				</a>
				<a name="_Toc9155">
				</a>
				<a name="__1">
				</a>
				<a name="sub671745_2_1">
				</a>
				<a name="旋转">
				</a>
				<a name="_-1">
					<span style="-aw-bookmark-end:sub671745_2">
					</span>
					<span style="-aw-bookmark-end:操作">
					</span>
					<span style="-aw-bookmark-end:__1">
					</span>
					<span style="-aw-bookmark-end:sub671745_2_1">
					</span>
					<span style="-aw-bookmark-end:旋转">
					</span>
				</a>
				<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
					旋转
				</span>
				<span style="-aw-bookmark-end:_Toc9155">
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					AVL树的基本操作一般涉及运做同在不平衡
				</span>
				<span style="font-family:等线; font-size:12pt">
					的二叉查找
				</span>
				<span style="font-family:等线; font-size:12pt">
					树所运做的同样的算法。但是要进行预先或
				</span>
				<span style="font-family:等线; font-size:12pt">
					随后做
				</span>
				<span style="font-family:等线; font-size:12pt">
					一次或多次所谓的"AVL旋转"。
				</span>
				<span style="font-family:等线; font-size:12pt">
					&#xa0;
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					假设由于在
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						二叉排序
					</span>
					<span style="font-family:等线; font-size:12pt">
						树
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					上插入结点而失去平衡的
				</span>
				<span style="font-family:等线; font-size:12pt">
					最
				</span>
				<span style="font-family:等线; font-size:12pt">
					小子树根结点的指针为a（即a是离插入点最近，且平衡因子绝对值超过1的祖先结点），则失去平衡后
				</span>
				<span style="font-family:等线; font-size:12pt">
					进行进行
				</span>
				<span style="font-family:等线; font-size:12pt">
					的规律可归纳为下列四种情况：
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					单向右旋平衡处理LL：由于在*a的左子树根结点的左子树上插入结点，*a的平衡因子由1增至2，致使以*a为根的子树失去平衡，则需进行一次右旋转操作；
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					单向左旋平衡处理RR：由于在*a
				</span>
				<span style="font-family:等线; font-size:12pt">
					的右子树根
				</span>
				<span style="font-family:等线; font-size:12pt">
					结点
				</span>
				<span style="font-family:等线; font-size:12pt">
					的右子树上
				</span>
				<span style="font-family:等线; font-size:12pt">
					插入结点，*a的平衡因子由-1变为-2，致使以*a为根的子树失去平衡，则需进行一次左旋转操作；
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					双向旋转（先左后右）平衡处理LR：由于在*a的左子树根结点
				</span>
				<span style="font-family:等线; font-size:12pt">
					的右子树上
				</span>
				<span style="font-family:等线; font-size:12pt">
					插入结点，*a的平衡因子由1增至2，致使以*a为根的子树失去平衡，则需进行两次旋转（先左旋后右旋）操作。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					双向旋转（先右后左）平衡处理RL：由于在*a
				</span>
				<span style="font-family:等线; font-size:12pt">
					的右子树根
				</span>
				<span style="font-family:等线; font-size:12pt">
					结点的左子树上插入结点，*a的平衡因子由-1变为-2，致使以*a为根的子树失去平衡，则需进行两次旋转（先右旋后左旋）操作。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="__2">
				</a>
				<a name="sub671745_2_2">
				</a>
				<a name="插入">
				</a>
				<a name="_-2">
				</a>
				<a name="_Toc2883">
					<span style="-aw-bookmark-end:__2">
					</span>
					<span style="-aw-bookmark-end:sub671745_2_2">
					</span>
					<span style="-aw-bookmark-end:插入">
					</span>
					<span style="-aw-bookmark-end:_-2">
					</span>
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						插入
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					向AVL树插入可以通过如同它是未平衡
				</span>
				<span style="font-family:等线; font-size:12pt">
					的二叉查找
				</span>
				<span style="font-family:等线; font-size:12pt">
					树一样把给定的值插入树中，接着自底向上向根
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E8%8A%82%E7%82%B9"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						节点
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					折回，于在插入期间成为不平衡的所有节点上进行旋转来完成。因为折回到根节点的路途上最多有1.5乘log
				</span>
				<span style="font-family:等线; font-size:12pt">
				</span>
				<span style="font-family:等线; font-size:12pt">
					n
				</span>
				<span style="font-family:等线; font-size:12pt">
					个
				</span>
				<span style="font-family:等线; font-size:12pt">
					节点，而每次AVL旋转都耗费恒定的时间，插入处理在整体上耗费O(log n)时间。在平衡的
				</span>
				<span style="font-family:等线; font-size:12pt">
					的
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						二叉排序
					</span>
					<span style="font-family:等线; font-size:12pt">
						树
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					Balanced BST上插入一个新的数据元素e的递归算法可描述如下：
				</span>
				<span style="font-family:等线; font-size:12pt">
				</span>
				<span style="font-family:等线; font-size:12pt">
					若BBST为空树，则插入一个数据元素为e的新结点作为BBST的根结点，树的深度增1； 若e的关键字和BBST的根结点的关键字相等，则不进行；
					若e的关键字小于BBST的根结点的关键字，而且在BBST的左子树中不存在和e有相同关键字的结点，则将e插入在BBST的左子树上，并且当插入之后的左子树深度增加（+1）时，分别就下列不同情况处理之：BBST的根结点的平衡因子为-1（
				</span>
				<span style="font-family:等线; font-size:12pt">
					右子树
				</span>
				<span style="font-family:等线; font-size:12pt">
					的深度大于左子树的深度，则将根结点的平衡因子更改为0，BBST的深度不变； BBST的根结点的平衡因子为0（左、
				</span>
				<span style="font-family:等线; font-size:12pt">
					右子树
				</span>
				<span style="font-family:等线; font-size:12pt">
					的深度相等）：则将根结点的平衡因子更改为1，BBST的深度增1； BBST的根结
				</span>
				<span style="font-family:等线; font-size:12pt">
					点的平衡因子为1（左子树的深度
				</span>
				<span style="font-family:等线; font-size:12pt">
					大于右子树
				</span>
				<span style="font-family:等线; font-size:12pt">
					的深度）：则若BBST的左子树根结点的平衡因子为1：则需进行单向右旋平衡处理，并且在右旋处理之后，将根结点和其右子树根结点的平衡因子更改为0，树的深度不变；
					若e的关键字大于BBST的根结点的关键字，而且在BBST
				</span>
				<span style="font-family:等线; font-size:12pt">
					的右子树中
				</span>
				<span style="font-family:等线; font-size:12pt">
					不存在和e有相同关键字的结点，则将e插入在BBST
				</span>
				<span style="font-family:等线; font-size:12pt">
					的右子树上
				</span>
				<span style="font-family:等线; font-size:12pt">
					，并且当插入之后
				</span>
				<span style="font-family:等线; font-size:12pt">
					的右子树
				</span>
				<span style="font-family:等线; font-size:12pt">
					深度增加（+1）时，分别就不同情况处理之。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="__3">
				</a>
				<a name="sub671745_2_3">
				</a>
				<a name="删除">
				</a>
				<a name="_-3">
				</a>
				<a name="_Toc52">
					<span style="-aw-bookmark-end:__3">
					</span>
					<span style="-aw-bookmark-end:sub671745_2_3">
					</span>
					<span style="-aw-bookmark-end:删除">
					</span>
					<span style="-aw-bookmark-end:_-3">
					</span>
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						删除
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					从AVL树中删除可以通过把要删除的
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E8%8A%82%E7%82%B9"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						节点
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					向下旋转成一个
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9"
				target="https://baike.baidu.com/item/_blank">
					<span style="font-family:等线; font-size:12pt">
						叶子节点
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					，接着直接剪除这个叶子节点来完成。因为在旋转成叶子节点期间最多有 log n
				</span>
				<span style="font-family:等线; font-size:12pt">
					个
				</span>
				<span style="font-family:等线; font-size:12pt">
					节点被旋转，而每次 AVL 旋转耗费恒定的时间，删除处理在整体上耗费 O(log n) 时间。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="__4">
				</a>
				<a name="sub671745_2_4">
				</a>
				<a name="查找">
				</a>
				<a name="_-4">
				</a>
				<a name="_Toc28354">
					<span style="-aw-bookmark-end:__4">
					</span>
					<span style="-aw-bookmark-end:sub671745_2_4">
					</span>
					<span style="-aw-bookmark-end:查找">
					</span>
					<span style="-aw-bookmark-end:_-4">
					</span>
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						查找
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					在AVL树中查找同在一般BST完全一样的进行，所以耗费 O(log n) 时间，因为AVL树总是保持平衡的。不需要特殊的准备，树的结构不会由于查询而改变。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:center; widows:0">
				<span style="color:#4472c4; font-family:华文彩云; font-size:22pt; font-weight:bold">
					哈希表
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列表
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						数据结构
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0/2366288"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列函数
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					，存放记录的
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%B0%E7%BB%84/3794097"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						数组
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					叫做
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8/10027933"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列表
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash)
					函数。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="_Toc18223">
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						6.1
					</span>
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						基本概念
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说
				</span>
				<span style="font-family:等线; font-size:12pt">
					称做
				</span>
				<span style="font-family:等线; font-size:12pt">
					同义词。综上所述，根据散列函数f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的
				</span>
				<span style="font-family:等线; font-size:12pt">
					“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的
				</span>
				<span style="font-family:等线; font-size:12pt">
					存储位置称散列地址
				</span>
				<span style="font-family:等线; font-size:12pt">
					。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					若对于关键字集合中的任一
				</span>
				<span style="font-family:等线; font-size:12pt">
					个
				</span>
				<span style="font-family:等线; font-size:12pt">
					关键字，经散列函数
				</span>
				<span style="font-family:等线; font-size:12pt">
					映象
				</span>
				<span style="font-family:等线; font-size:12pt">
					到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="sub329976_2">
				</a>
				<a name="常用方法">
				</a>
				<a name="_Toc13725">
					<span style="-aw-bookmark-end:sub329976_2">
					</span>
					<span style="-aw-bookmark-end:常用方法">
					</span>
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						6.2
					</span>
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						常用方法
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列函数
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					能使对一个数据序列的访问过程更加迅速有效，通过散列函数，
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						数据元素
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					将被更快地定位。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					实际工作中需视不同的情况采用不同的
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						哈希函数
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					，通常考虑的因素有：
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					· 计算
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						哈希函数
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					所需时间
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					· 关键字的长度
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					· 哈希表的大小
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					· 关键字的分布情况
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					· 记录的查找频率
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a style="color:#4472c4" href="https://baike.baidu.com/item/%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="color:#4472c4; font-family:等线; font-size:14pt; font-variant:small-caps; font-weight:bold; letter-spacing:0.25pt">
						直接寻址
					</span>
				</a>
				<span style="color:#4472c4; font-family:等线; font-size:14pt; font-variant:small-caps; font-weight:bold; letter-spacing:0.25pt">
					法
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) =
				</span>
				<span style="font-family:等线; font-size:12pt">
					a·key
				</span>
				<span style="font-family:等线; font-size:12pt">
					+ b，其中a和b为常数（这种
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列函数
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="color:#4472c4; font-family:等线; font-size:14pt; font-variant:small-caps; font-weight:bold; letter-spacing:0.25pt">
					数字分析法
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="color:#4472c4; font-family:等线; font-size:14pt; font-variant:small-caps; font-weight:bold; letter-spacing:0.25pt">
					平方取中法
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					当无法
				</span>
				<span style="font-family:等线; font-size:12pt">
					确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要
				</span>
				<span style="font-family:等线; font-size:12pt">
					取平方值的
				</span>
				<span style="font-family:等线; font-size:12pt">
					中间几位作为哈希地址。这是因为：
				</span>
				<span style="font-family:等线; font-size:12pt">
					平方后
				</span>
				<span style="font-family:等线; font-size:12pt">
					中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址
				</span>
				<a name="ref__1__329976">
					<span style="font-family:等线; font-size:12pt">
						。
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="color:#4472c4; font-family:等线; font-size:14pt; font-variant:small-caps; font-weight:normal; letter-spacing:0.25pt">
					折叠法
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="color:#4472c4; font-family:等线; font-size:14pt; font-variant:small-caps; font-weight:bold; letter-spacing:0.25pt">
					随机数法
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					选择
				</span>
				<span style="font-family:等线; font-size:12pt">
					一
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E5%87%BD%E6%95%B0"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						随机函数
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					，取关键字的随机值作为散列地址，即H(key)=random(key)其中random为随机函数,通常用于关键字长度不等的场合。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="color:#4472c4; font-family:等线; font-size:14pt; font-variant:small-caps; font-weight:normal; letter-spacing:0.25pt">
					除留余数法
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					取关键字被某个不大于
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列表
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					表长
				</span>
				<span style="font-family:等线; font-size:12pt">
					m的数p除后所得的余数为散列地址。即 H(key) = key MOD
				</span>
				<span style="font-family:等线; font-size:12pt">
					p,p
				</span>
				<span style="font-family:等线; font-size:12pt">
					&lt;=m。不仅可以对
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						关键字
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="_">
				</a>
				<a name="sub329976_3">
				</a>
				<a name="处理冲突">
				</a>
				<a name="_Toc16456">
					<span style="-aw-bookmark-end:_">
					</span>
					<span style="-aw-bookmark-end:sub329976_3">
					</span>
					<span style="-aw-bookmark-end:处理冲突">
					</span>
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						6.3
					</span>
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						处理冲突
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					1.
				</span>
				<span style="font-family:等线; font-size:12pt">
					&#xa0;
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E5%BC%80%E6%94%BE%E5%AF%BB%E5%9D%80%E6%B3%95"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						开放寻址法
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					：Hi=(H(key) + di) MOD
				</span>
				<span style="font-family:等线; font-size:12pt">
					m,i
				</span>
				<span style="font-family:等线; font-size:12pt">
					=1,2，…，k(k&lt;=m-1），其中H(key）为
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列函数
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					，m为
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列表
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					长，di为增量序列，可有下列三种取法：
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					1.1. di=1,2,3，…，m-1，称线性
				</span>
				<span style="font-family:等线; font-size:12pt">
					探测再
				</span>
				<span style="font-family:等线; font-size:12pt">
					散列；
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					1.2. di=1^2,-1^2,2^2,-2^2，⑶^2，…，±（k)^2,(k&lt;=m/2）称二次
				</span>
				<span style="font-family:等线; font-size:12pt">
					探测再
				</span>
				<span style="font-family:等线; font-size:12pt">
					散列；
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					1.3. di=
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						伪随机数
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					序列，
				</span>
				<span style="font-family:等线; font-size:12pt">
					称伪随机探测再
				</span>
				<span style="font-family:等线; font-size:12pt">
					散列。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					2. 再
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E6%B3%95"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列法
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					：Hi=
				</span>
				<span style="font-family:等线; font-size:12pt">
					RHi
				</span>
				<span style="font-family:等线; font-size:12pt">
					(key),
				</span>
				<span style="font-family:等线; font-size:12pt">
					i
				</span>
				<span style="font-family:等线; font-size:12pt">
					=1,2，…，k
				</span>
				<span style="font-family:等线; font-size:12pt">
					RHi
				</span>
				<span style="font-family:等线; font-size:12pt">
					均是不同的
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列函数
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					3. 链地址法（拉链法）
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					4. 建立一个公共溢出区
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a name="_">
				</a>
				<a name="sub329976_4">
				</a>
				<a name="查找性能">
				</a>
				<a name="_Toc14931">
					<span style="-aw-bookmark-end:_">
					</span>
					<span style="-aw-bookmark-end:sub329976_4">
					</span>
					<span style="-aw-bookmark-end:查找性能">
					</span>
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						6.4
					</span>
					<span style="color:#4472c4; font-family:华文楷体; font-size:18pt; font-weight:bold">
						查找性能
					</span>
				</a>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列表
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					的查找过程基本上和造表过程相同。一些关键码可通过
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列函数
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在介绍的三种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键码进行比较的过程。所以，对
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列表
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					查找效率的量度，依然用平均查找长度来衡量。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影响产生冲突多少有以下三个因素：
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					1.
				</span>
				<span style="font-family:等线; font-size:12pt">
					&#xa0;
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列函数
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					是否均匀；
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					2. 处理冲突的方法；
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					3.
				</span>
				<span style="font-family:等线; font-size:12pt">
					&#xa0;
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列表
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					的装填因子。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列表
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					的装填因子定义为：α= 填入表中的元素个数 / 散列表的长度
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					α是
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列表
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					装满程度的标志因子。
				</span>
				<span style="font-family:等线; font-size:12pt">
					由于表长是
				</span>
				<span style="font-family:等线; font-size:12pt">
					定值，α与“填入表中的元素个数”成正比，所以，α越大，填入表中的元素较多，产生冲突的可能性就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小。
				</span>
			</p>
			<p style="margin:0pt; orphans:0; text-align:justify; text-indent:21pt; widows:0">
				<span style="font-family:等线; font-size:12pt">
					实际上，
				</span>
				<a style="color:#000000" href="https://baike.baidu.com/item/%E6%95%A3%E5%88%97%E8%A1%A8"
				target="https://baike.baidu.com/item/%E5%93%88%E5%B8%8C%E8%A1%A8/_blank">
					<span style="font-family:等线; font-size:12pt">
						散列表
					</span>
				</a>
				<span style="font-family:等线; font-size:12pt">
					的平均查找长度是装填因子α的函数，只是不同处理冲突的方法有不同的函数。
				</span>
			</p>
		</div>
		<div class="cnzz" style="display: none;">
			<script src="https://s23.cnzz.com/z_stat.php?id=1277655852&web_id=1277655852"
			language="JavaScript">
			</script>
		</div>

	</body>

</html>